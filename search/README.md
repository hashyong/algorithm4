# 查找算法

- [find](search)
  - 查找相关算法
    - [无序链表](search)
    - [基于有序数组的二叉查找版本](search)
    - [二叉查找树(BST)](search)
    - [平衡查找树](search)
      - [伸展树](search)
      - [B-树](search)
      - [2-3查找树](search)
        - 树从下向上生长, 保持平衡关键
      - [左倾红黑树](search)
        - 定义
          - 3 节点 用红链接代替
          - 2 节点 正常黑色链接
          - 红链接均为左链接;
          - 没有任何一个结点同时和两条红链接相连;
          - 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。
          - 满足这样定义的红黑树和相应的 2-3 树是一一对应的。
        - 为何高效？
          - 红黑树都既是二叉查找树，也是 2-3 树, 结合两者优点，优秀
            - 二叉查找树中简洁高效的查找方法
            - 2-3 树中高效 的平衡插入算法
        - 图解系列
          - [图解红黑树插入](https://github.com/hashyong/drawio/blob/main/rbtree.jpg)
          - [图解红黑树删除](https://github.com/hashyong/drawio/blob/main/rbtree.jpg)
            - 说句题外话， 红黑树的删除此书没讲明白， 建议看下 数据结构与算法(邓俊辉版本)
            - 其实本质上还是B树的删除，左倾红黑树就是3阶B树删除， 正常红黑树就是4阶B树删除
            - B树的删除也很简单
              - 假如删除的是非叶子节点，找到对应前驱或者是后继节点交换，再删除对应叶子节点
              - 假如删除的是叶子节点，分几种情况
                - 1. 本身不是2节点，那简单了， 直接删了就行，树的平衡性不会被破坏
                - 2. 本身是2节点，这就有意思了， 删除之后会导致当前节点为空，完美黑色平衡被破坏，我们称为下溢 那咋办呢？借呗
                  - 2.1 优先向兄弟节点借一个，假如兄弟节点不是2节点，借一个过来就行
                  - 2.2 兄弟节点是2节点，再借也自己就空了，向父节点借一个
                    - 2.2.1 父节点不是2节点， 那没问题 借一个就舒服了，然后和兄弟节点合并即可
                    - 2.2.2 父节点是2节点，得，父节点也空了，我们称为 下溢的传递，父节点再按照之前流程处理即可, 当下溢至根节点时，整个树的高度下降1
          - 来吧， 一起手撕红黑树吧
      - [正常红黑树](search)
    - [散列表](search)
      - [基于拉链法散列表](search)
      - [基于线性探测法散列表](search)
    - [跳跃链表](search)
      - 本质为基于概率来保证查找性能
      - 相当于多级索引，加快查找速度

## 最最最基础的无序链表版本 
- [SeqSearchST](search.go)

## 基于有序数组的二叉查找版本
- [BinarySearchST](binary_search_st.go)

## BST
- [BST](binary_search_tree.go)
  - 支持以下接口 
    - get, put, size, range, select, floor, delmin, delmax, del

## 左倾红黑树  
- [LeftRedBlackTree](left_rb_tree.go)
- 图解插入流程
  
![图解插入](https://github.com/hashyong/drawio/blob/main/rbtree.jpg)

## hash表
- 过于简单， 此处不展开
- 解决冲突分为两种方法
  1. 基于拉链法， 冲突之后往链表上挂数据就行， 假如太多， 建议转为红黑树
  2. 基于线性探测法， 往后找，有空的直接插入即可